# 第一章

## 1. 掌握进程虚拟地址空间区域划分

编程语言产生：指令+数据

exe 磁盘加载到内存，不可能直接加载到内存。

x86系统：linux系统会给当前进程分配一个 2^32 大小的空间 4G

它不存在，你却看得见，它是虚拟的。



0x00000000 ~ 0xC0000000 用户空间 user space 3G 

0xC0000000 ~ 0xFFFFFFFF kernal space 内核空间 1G



0x00000000 ~ 0x08048000 不能被访问

.text段（指令）； .rodata(只读数据段)； .data； .bss； .heap； 加载共享库 *.dll *.so； stack；命令行参数和环境变量；ZONE_DMA/ZONE_NORMAL/ZONE_HIGHMEM。

比如 `char *s = "asd";` 只能读、不能写。

```c
//空指针
char *s = 0;
printf("%ld", strlen(s));
//段错误 (核心已转储)
```

`int a = 12;` 指令在 text 段，运行时在栈。

每一个进程的用户空间是私有的，但是内核空间是共享的。



## 2. 从指令的角度掌握函数调用堆栈的详细过程

ebp栈底 和 esp栈顶 这两个指针秀操作

汇编里面相对地址 往上是减法操作、往下是加法（不理解）

mov 赋值 和 ebp 有关

push 压栈 和 esp 有关

左右括号：左括号申请栈空间、右括号还原。

形参直接往esp上 push  返回答案直接用eax寄存器

<= 4 字节 eax

`>4 && <= 8` eax edx

`> 8` 产生临时量



## 3. 从编译器角度理解C++代码的编译和链接原理

编译过程 + 链接过程

---

编译过程：

1. 预编译：#开头的命令（#pragma除外 链接阶段）

2. 编译：gcc g++

3. 汇编：x86 AT&T(unix系统)

4. .o ：二进制可重定位的目标文件

---

链接：编译完成的所有 .o 文件+静态库文件

1. 所有.o文件段的合并。符号表合并后，进行符号解析。（符号解析：所有对符号的引用，都要找到该符号定义的地方。）
2. 核心，符号的重定向。符号解析成功后给所有的符号分配虚拟地址，并将指令填上具体地址。

---

![在这里插入图片描述](https://img-blog.csdnimg.cn/0e67258074aa46c08b7128e37723f8b9.png)

l 是 local ，g 是 全局可见

`*UND*` 是对符号的引用



readelf -S main.o 把段打印出来看

```
// 生成调试信息
g++ -c main.cpp -g
objdump -S main.o
```

编译过程中，符号不分配虚拟地址，会发现地址是 0，所以 .o 运行不了  

----

.o 文件各个相同的段合并

---

![在这里插入图片描述](https://img-blog.csdnimg.cn/caafb7f2ce1849e89c5f624e6e3f29a3.png)

但是直接 g++ 两个文件没有问题。应该是不详细吧。
