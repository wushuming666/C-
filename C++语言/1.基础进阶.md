学习资料 https://github.com/Light-City/CPlusPlusThings

# 1. const

## 1.1 const含义

常类型是指使用类型修饰符**const**说明的类型，常类型的变量或对象的值是不能被更新的。

## 1.2 const作用

1. 可以定义常量

   ```cpp
   const int N = 1e5 + 7;
   ```

2. 类型检查

   * const定义的变量要初始化。

3. 防止修改，起保护作用，增加程序健壮性

4. 可以节省空间，避免不必要的内存分配
   * const定义常量从汇编的角度来看，只是给出了对应的内存地址，而不是像`#define`一样给出的是立即数。
   * const定义的常量在程序运行过程中只有一份拷贝，而`#define`定义的常量在内存中有若干个拷贝。

## 1.3 const对象默认为文件局部变量

注意：非const变量默认为extern。要使const变量能够在其他文件中访问，必须在文件中显式地指定它为extern。

> 未被const修饰的变量在不同文件的访问

```cpp
//file1.cpp
int ext = 2;
//file2.cpp
#include <iostream>
extern int ext;
int main() {
    std::cout<<(ext+7)<<std::endl; //9
}
```

> const常量在不同文件的访问

```cpp
//file1.cpp
extern const int ext = 2;
//file2.cpp
#include <iostream>
extern const int ext;
int main() {
    std::cout<<(ext+7)<<std::endl; //9
}
```

## 1.4 定义变量

要赋初值、不能再改变

## 1.5 指针与const

> 如果*const*位于`*`的左侧，则const就是用来修饰指针所指向的变量，即指针指向为常量；
>
> 如果const位于`*`的右侧，*const*就是修饰指针本身，即指针本身是常量。

```cpp
const char * a; //指向const对象的指针或者说指向常量的指针。
char const * a; //同上
char * const a; //指向类型对象的const指针。或者说常指针、const指针。
const char * const a; //指向const对象的const指针。
```

（1） **指向常量的指针**

```cpp
const int *ptr; //const定义的是int类型，也就是ptr所指向的对象类型
*ptr = 10; //error
```

除此之外，也不能使用void`*`指针保存const对象的地址，必须使用const void`*`类型的指针保存const对象的地址。

```cpp
const int p = 10;
const void * vp = &p; //yes
void *vp = &p; //error
```

**允许把非const对象的地址赋给指向const对象的指针**。

```cpp
const int *ptr;
int val = 3;
ptr = &val; //ok 
```

这里不能通过ptr改变数字，但是可以用另一个指针修改数字

```cpp
int *ptr2 = &val;
*ptr2 = 10;
cout << *ptr << endl;
```

> 小结：
> 1.对于指向常量的指针，不能通过指针来修改对象的值。
> 2.不能使用void`*`指针保存const对象的地址，必须使用const void`*`类型的指针保存const对象的地址。
> 3.允许把非const对象的地址赋值给const对象的指针，如果要修改指针所指向的对象值，必须通过其他方式修改，不能直接通过当前指针直接修改。

（2） **常指针**

指针不能被改变

```cpp
#include<iostream>
using namespace std;
int main()
{
    int num=0;
    int * const ptr=&num; //const指针必须初始化！且const指针的值不能修改
    int * t = &num;
    *t = 1;
    cout<<*ptr<<endl;
}
```

常指针只是本身这个指针是常量

```cpp
#include<iostream>
using namespace std;
int main(){
    const int num=0;
    //修改为 const int * const ptr=&num;
    const int * const ptr=&num; //error! const int* -> int*
    cout<<*ptr<<endl;
}
```

（3）**指向常量的常指针**

```cpp
const int p = 3;
const int * const ptr = &p; 
```

## 1.6 函数中使用const

> const修饰函数返回值

（1）**const int**

无意义

（2）**const int***

指针指向的内容不变。

（3）int *const

指针本身不可变



> const修饰函数参数

（1）传递过来的参数及指针本身在函数内不可变，无意义

```cpp
void func(const int var); // 传递过来的参数不可变，无意义
void func(int *const var); // 指针本身不可变
```

（2）**参数指针所指内容为常量不可变**

```cpp
void StringCopy(char *dst, const char *src);
```

（3）**参数为引用，为了增加效率同时防止修改。**

```cpp
void func(const A &a)
```

是否应将void func(int x) 改写为void func(const int &x)，以便提高效率？完全没有必要，因为内部数据类型的参数不存在构造、析构的过程，而复制也非常快，“值传递”和“引用传递”的效率几乎相当。

## 1.7 类中使用const

在一个类中，任何不会修改数据成员的函数都应该声明为const类型。如果在编写const成员函数时，不慎修改数据成员，或者调用了其它非const成员函数，编译器将指出错误，这无疑会提高程序的健壮性。

使用const关键字进行说明的成员函数，称为常成员函数。只有常成员函数才有资格操作常量或常对象，没有使用const关键字进行说明的成员函数不能用来操作常对象。

对于类中的const成员变量必须通过初始化列表进行初始化，应该是某个古老的版本。

const成员函数只能访问const成员函数。

```cpp
//apple.cpp
class Apple
{
private:
    int people[100];
public:
    Apple(int i); 
    const int apple_number;
    void take(int num) const;
    int add();
    int add(int num) const;
    int getCount() const;

};
//main.cpp
#include<iostream>
#include"apple.cpp"
using namespace std;

Apple::Apple(int i):apple_number(i)
{

}
int Apple::add(){
    take(1);
    return 0;
}
int Apple::add(int num) const{
    take(num);
    return num;
}
void Apple::take(int num) const
{
    cout<<"take func "<<num<<endl;
}
int Apple::getCount() const
{
    take(1);
    add();  // error
    return apple_number;
}
int main(){
    Apple a(2);
    cout<<a.getCount()<<endl;
    a.add(10);
    return 0;
}
```



# 2. static

可以使用static关键字：

1. 静态变量
2. 静态类的成员

## 2.1 **静态变量**

1. 函数中的静态变量

   即使多次调用该函数，静态变量的空间也**只分配一次**

2. 类中的静态变量

   由于声明为static的变量只被初始化一次，因为它们在单独的静态存储中分配了空间，因此类中的静态变量**由对象共享**。对于不同的对象，不能有相同静态变量的多个副本。也是因为这个原因，静态变量不能使用构造函数初始化。

   ```cpp
   #include<iostream> 
   using namespace std; 
   
   class Apple 
   { 
   public: 
   	static int i; 
   	
   	Apple() 
   	{ 
   		// Do nothing 
   	}; 
   }; 
   
   int Apple::i = 1; 
   
   int main() 
   { 
   	Apple obj; 
   	// prints value of i 
   	cout << obj.i; 
   } 
   ```

## 2.2 **静态成员**

1. 类对象为静态

   ```cpp
   #include<iostream> 
   using namespace std; 
   
   class Apple 
   { 
   	int i; 
   	public: 
   		Apple() 
   		{ 
   			i = 0; 
   			cout << "Inside Constructor\n"; 
   		} 
   		~Apple() 
   		{ 
   			cout << "Inside Destructor\n"; 
   		} 
   }; 
   
   int main() 
   { 
   	int x = 0; 
   	if (x==0) 
   	{ 
   		Apple obj; 
   	} 
   	cout << "End of main\n"; 
   } 
   
   //Inside Constructor
   //Inside Destructor
   //End of main
   //原因:对象在if块内声明为非静态。因此，变量的范围仅在if块内。
   ```

   ```cpp
   #include<iostream> 
   using namespace std; 
   
   class Apple 
   { 
   	int i; 
   	public: 
   		Apple() 
   		{ 
   			i = 0; 
   			cout << "Inside Constructor\n"; 
   		} 
   		~Apple() 
   		{ 
   			cout << "Inside Destructor\n"; 
   		} 
   }; 
   
   int main() 
   { 
   	int x = 0; 
   	if (x==0) 
   	{ 
   		static Apple obj; 
   	} 
   	cout << "End of main\n"; 
   } 
   
   /*
   Inside Constructor
   End of main
   Inside Destructor
   静态对象的范围是贯穿程序的生命周期
   */
   ```

2. 类中的静态函数

   允许静态成员函数仅访问静态数据成员或其他静态成员函数，它们无法访问类的非静态数据成员或成员函数。

   ```cpp
   #include<iostream> 
   using namespace std; 
   
   class Apple 
   { 
       public: 
           // static member function 
           static void printMsg() 
           {
               cout<<"Welcome to Apple!"; 
           }
   }; 
   
   // main function 
   int main() 
   { 
       // invoking a static member function 
       Apple::printMsg(); 
   } 
   
   //Welcome to Apple!
   ```

   **限定访问范围** static还有限定访问范围的作用（类似于匿名名字空间）。

   ```cpp
   // source1.cpp
   extern void sayHello();
   static const char* msg = "Hello World!\n"; //去掉static后正常运行
   int main()
   {
       sayHello();
       return 0;
   }
   
   // source2.cpp
   #include <cstdio>
   extern char* msg;
   void sayHello()
   {
       printf("%s", msg);
   }
   ```

   

# 3. this

在 C++ 中，每一个对象都能通过 **this** 指针来访问自己的地址。**this** 指针是所有成员函数的隐含参数。

友元函数没有 **this** 指针，因为友元不是类的成员。只有成员函数才有 **this** 指针。

this指针的用处：

1. 一个对象的this指针并不是对象本身的一部分，不会影响sizeof(对象)的结果。
2. this作用域是在类内部，当在类的非静态成员函数中访问类的非静态成员的时候，编译器会自动将对象本身的地址作为一个隐含参数传递给函数。也就是说，即使你没有写上this指针，编译器在编译的时候也是加上this的，它作为非静态成员函数的隐含形参，对各成员的访问均通过this进行。

其次，this指针的使用：

1. 在类的非静态成员函数中返回类对象本身的时候，直接使用 return *this。
2. 当参数与成员变量名相同时，如this->n = n （不能写成n = n)。

总结：this在成员函数的开始执行前构造，在成员的执行结束后清除。



# 4. inline

## 4.1 类中关联

```cpp
//inline.h
#ifndef INLINE_H
#define INLINE_H

class A
{
public:
//    void f1(int x);

    /**
     * @brief 类中定义了的函数是隐式内联函数,声明要想成为内联函数，必须在实现处(定义处)加inline关键字。
     *
     * @param x
     * @param y
     */
    void Foo(int x,int y) ///< 定义即隐式内联函数！
    {

    };
    void f1(int x); ///< 声明后，要想成为内联函数，必须在定义处加inline关键字。
};

#endif // INLINE_H

//main.cpp
#include <iostream>
#include "inline.h"

using namespace std;

/**
 * @brief inline要起作用,inline要与函数定义放在一起,inline是一种“用于实现的关键字,而不是用于声明的关键字”
 *
 * @param x
 * @param y
 *
 * @return
 */
int Foo(int x,int y);  // 函数声明
inline int Foo(int x,int y) // 函数定义
{
    return x+y;
}

// 定义处加inline关键字，推荐这种写法！
inline void A::f1(int x){

}

int main()
{


    cout<<Foo(1,2)<<endl;

}
/**
 * 编译器对 inline 函数的处理步骤
 * 将 inline 函数体复制到 inline 函数调用点处；
 * 为所用 inline 函数中的局部变量分配内存空间；
 * 将 inline 函数的的输入参数和返回值映射到调用方法的局部变量空间中；
 * 如果 inline 函数有多个返回点，将其转变为 inline 函数代码块末尾的分支（使用 GOTO）。
 */

```

内联是以代码膨胀(复制)为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。

以下情况不宜用内联：

1. 如果函数体内的代码比较长，使得内联将导致内存消耗代价比较高。
2. 如果函数体内出现循环，那么执行函数体内代码的时间要比函数调用的开销大。

## 4.2 虚函数（virtual）可以是内联函数（inline）吗？

* 虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。
* 内联是在编译期建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。
* `inline virtual` 唯一可以内联的时候是：编译器知道所调用的对象是哪个类（如 `Base::who()`），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。

```cpp
//没太看懂这个例子想表达什么
#include <iostream>  
using namespace std;
class Base
{
public:
    inline virtual void who()
    {
        cout << "I am Base\n";
    }
    virtual ~Base() {}
};
class Derived : public Base
{
public:
    inline void who()  // 不写inline时隐式内联
    {
        cout << "I am Derived\n";
    }
};

int main()
{
    // 此处的虚函数 who()，是通过类（Base）的具体对象（b）来调用的，编译期间就能确定了，所以它可以是内联的，但最终是否内联取决于编译器。 
    Base b;
    b.who();

    // 此处的虚函数是通过指针调用的，呈现多态性，需要在运行时期间才能确定，所以不能为内联。  
    Base *ptr = new Derived();
    ptr->who();

    // 因为Base有虚析构函数（virtual ~Base() {}），所以 delete 时，会先调用派生类（Derived）析构函数，再调用基类（Base）析构函数，防止内存泄漏。
    delete ptr;
    ptr = nullptr;

    //system("pause");
    return 0;
} 
```



# 5. sizeof

先给出总结：

* 空类的大小为1字节
* 一个类中，虚函数本身、成员函数（包括静态与非静态）和静态数据成员都是不占用类对象的存储空间。
* 对于包含虚函数的类，不管有多少个虚函数，只有一个虚指针,vptr的大小。
* 普通继承，派生类继承了所有基类的函数与成员，要按照字节对齐来计算大小
* 虚函数继承，不管是单继承还是多继承，都是继承了基类的vptr。(32位操作系统4字节，64位操作系统 8字节)！
* 虚继承,继承基类的vptr。

```cpp
/**
 * @file blackclass.cpp
 * @brief 空类的大小为1字节
 * @author 光城
 * @version v1
 * @date 2019-07-21
 */
#include<iostream>
using namespace std;
class A{};
int main()
{
    cout<<sizeof(A)<<endl;
    return 0;
}
```

```cpp
/**
 * @file static.cpp
 * @brief 静态数据成员
 * 静态数据成员被编译器放在程序的一个global data members中，它是类的一个数据成员，但不影响类的大小。不管这个类产生了多少个实例，还是派生了多少新的类，静态数据成员只有一个实例。静态数据成员，一旦被声明，就已经存在。
 * @author 光城
 * @version v1
 * @date 2019-07-21
 */
#include<iostream>
using namespace std;
class A
{
    public:
        char b;
        virtual void fun() {};
        static int c; //static不占类的空间
        static int d;
        static int f;
};

int main()
{
    /**
     * @brief 16  字节对齐、静态变量不影响类的大小、vptr指针=8
     */
    cout<<sizeof(A)<<endl;
    return 0;
}

```

```cpp
/**
 * @file morevir.cpp
 * @brief 对于包含虚函数的类，不管有多少个虚函数，只有一个虚指针,vptr的大小。
 * @author 光城
 * @version v1
 * @date 2019-07-21
 */
#include<iostream>
using namespace std;
class A{
    virtual void fun();
    virtual void fun1();
    virtual void fun2();
    virtual void fun3();
};
int main()
{
    cout<<sizeof(A)<<endl; // 8
    return 0;
}

```

```cpp
/**
 * @file geninhe.cpp
 * @brief 1.普通单继承,继承就是基类+派生类自身的大小(注意字节对齐)
 * 注意：类的数据成员按其声明顺序加入内存，无访问权限无关，只看声明顺序。
 * 2.虚单继承，派生类继承基类vptr
 * @author 光城
 * @version v1
 * @date 2019-07-21
 */

#include<iostream>

using namespace std;

class A
{
    public:
        char a;
        int b;
};

/**
 * @brief 此时B按照顺序：
 * char a
 * int b
 * short a
 * long b
 * 根据字节对齐4+4+8+8=24
 *
 * 或编译器优化
 * char a
 * short a
 * int b
 * long b
 * 根据字节对齐2+2+4+8=16
 */
class B:A
{
    public:
        short a;
        long b;
};
/**
* 把A的成员拆开看，char为1，int为4，所以是1+（3）+4+1+（3）=12，（）为字节补齐
*/
class C
{
    A a;
    char c;
};

class A1
{
    virtual void fun(){}
};
class C1:public A
{
};


int main()
{
    cout<<sizeof(A)<<endl; // 8
    cout<<sizeof(B)<<endl; // 16 或 24
    cout<<sizeof(C)<<endl; // 12

    /**
     * @brief 对于虚单函数继承，派生类也继承了基类的vptr，所以是8字节
     */
    cout<<sizeof(C1)<<endl; // 8
    return 0;
}

```

```cpp
/**
 * @file virnhe.cpp
 * @brief 虚继承
 * @author 光城
 * @version v1
 * @date 2019-07-21
 */

#include<iostream>
using namespace std;
class A
{
    virtual void fun() {}
};
class B
{
    virtual void fun2() {}
};
class C : virtual public  A, virtual public B
{
    public:
        virtual void fun3() {}
};

int main()
{
    /**
     * @brief 8 8 16  派生类虚继承多个虚函数，会继承所有虚函数的vptr
     */
    cout<<sizeof(A)<<" "<<sizeof(B)<<" "<<sizeof(C);

    return 0;
}

```



# 6. 函数指针

```cpp
//有没有*都是对的
/**
 * @file func_pointer.cpp
 * @brief 函数指针的使用！
 * @author 光城
 * @version v1
 * @date 2019-07-20
 */

#include<iostream>
using namespace std;

/**
 * @brief 定义了一个变量pFun，这个变量是个指针，指向返回值为空和参数为int的函数的指针！
 */
void (*pFun)(int);

/**
 * @brief 代表一种新类型，不是变量！所以与上述的pFun不一样！
 */
typedef void (*func)(void);

void myfunc(void)
{
    cout<<"asda"<<endl;
}

void glFun(int a){ cout<<a<<endl;}
int main(){
    func pfun = myfunc;/*赋值*/
    pfun();/*调用*/
    pFun = glFun;
    (*pFun)(2); //pFun(2); 也能执行
}
```



# 7. 纯虚函数和抽象类

## 7.1 纯虚函数和抽象类

C++中的纯虚函数(或抽象函数)是我们没有实现的虚函数！我们只需声明它! 通过声明中赋值0来声明纯虚函数！

```cpp
// 抽象类
Class A {
public: 
    virtual void show() = 0; // 纯虚函数
    /* Other members */
}; 
```

只要有纯虚函数就是抽象类

```cpp
/**
 * @file pure_virtual.cpp
 * @brief 纯虚函数：没有函数体的虚函数
 * 抽象类：包含纯虚函数的类
 *
 * @author 光城
 * @version v1
 * @date 2019-07-20
 */

#include<iostream>

using namespace std;
class A
{
private:
    int a;
public:
    virtual void show()=0; // 纯虚函数
};


int main()
{
    /*
     * 1. 抽象类只能作为基类来派生新类使用
     * 2. 抽象类的指针和引用->由抽象类派生出来的类的对象！
     */
    A a; // error 抽象类，不能创建对象

    A *a1; // ok 可以定义抽象类的指针

    A *a2 = new A(); // error, A是抽象类，不能创建对象
}

```

## 7.2 实现抽象类

抽象类中：在成员函数内可以调用纯虚函数，在构造函数/析构函数内部不能使用纯虚函数。

如果一个类从抽象类派生而来，它必须实现了基类中的所有纯虚函数，才能成为非抽象类。

```cpp
/**
 * @file abstract.cpp
 * @brief 抽象类中：在成员函数内可以调用纯虚函数，在构造函数/析构函数内部不能使用纯虚函数
 * 如果一个类从抽象类派生而来，它必须实现了基类中的所有纯虚函数，才能成为非抽象类
 * @author 光城
 * @version v1
 * @date 2019-07-20
 */

#include<iostream>
using namespace std;

class A {
public:
    virtual void f() = 0;  // 纯虚函数
    void g(){ this->f(); }
    A(){}
};
class B:public A{
public:
    void f(){ cout<<"B:f()"<<endl;}
};
int main(){
    B b;
    b.g();
    return 0;
}

```

## 7.3  重要点

* [纯虚函数使一个类变成抽象类](https://github.com/Light-City/CPlusPlusThings/blob/master/basic_content/abstract/interesting_facts1.cpp)

  ```cpp
  #include<iostream>
  using namespace std;
  
  /**
   * @brief 抽象类至少包含一个纯虚函数
   */
  class Test
  {
      int x;
  public:
      virtual void show() = 0;
      int getX() { return x; }
  };
  
  int main(void)
  {
      Test t;  //error! 不能创建抽象类的对象
      return 0;
  }
  ```

* [抽象类类型的指针和引用](https://github.com/Light-City/CPlusPlusThings/blob/master/basic_content/abstract/interesting_facts2.cpp)

  ```cpp
  /**
   * @file interesting_facts2.cpp
   * @brief 抽象类类型的指针和引用
   * @author 光城
   * @version v1
   * @date 2019-07-20
   */
  
  #include<iostream>
  using namespace std;
  
  
  /**
   * @brief 抽象类至少包含一个纯虚函数
   */
  class Base
  {
      int x;
  public:
      virtual void show() = 0;
      int getX() { return x; }
  
  };
  class Derived: public Base
  {
  public:
      void show() { cout << "In Derived \n"; }
      Derived(){}
  };
  int main(void)
  {
  //    Base b;  //error! 不能创建抽象类的对象
  //    Base *b = new Base(); error!
      Base *bp = new Derived(); // 抽象类的指针和引用 -> 由抽象类派生出来的类的对象
      bp->show();
      return 0;
  }
  
  ```

* [如果我们不在派生类中覆盖纯虚函数，那么派生类也会变成抽象类](https://github.com/Light-City/CPlusPlusThings/blob/master/basic_content/abstract/interesting_facts3.cpp)

  ```cpp
  /**
   * @file interesting_facts3.cpp
   * @brief 如果我们不在派生类中覆盖纯虚函数，那么派生类也会变成抽象类。
   * @author 光城
   * @version v1
   * @date 2019-07-20
   */
  
  #include<iostream>
  using namespace std;
  
  class Base
  {
      int x;
  public:
      virtual void show() = 0;
      int getX() { return x; }
  };
  class Derived: public Base
  {
  public:
  //    void show() { }
  };
  int main(void)
  {
      Derived d;  //error! 派生类没有实现纯虚函数，那么派生类也会变为抽象类，不能创建抽象类的对象
      return 0;
  }
  
  ```

* [抽象类可以有构造函数](https://github.com/Light-City/CPlusPlusThings/blob/master/basic_content/abstract/interesting_facts4.cpp)

  ```cpp
  /**
   * @file interesting_facts4.cpp
   * @brief 抽象类可以有构造函数
   * @author 光城
   * @version v1
   * @date 2019-07-20
   */
  
  #include<iostream>
  using namespace std;
  
  // An abstract class with constructor
  class Base
  {
      protected:
          int x;
      public:
          virtual void fun() = 0;
          Base(int i) { x = i; }
  };
  
  class Derived: public Base
  {
      int y;
      public:
          Derived(int i, int j):Base(i) { y = j; }
          void fun() { cout << "x = " << x << ", y = " << y; }
  };
  
  int main(void)
  {
      Derived d(4, 5);
      d.fun();
      return 0;
  }
  
  ```

* [构造函数不能是虚函数，而析构函数可以是虚析构函数](https://github.com/Light-City/CPlusPlusThings/blob/master/basic_content/abstract/interesting_facts5.cpp)

  ```cpp
  #include<iostream>
  using namespace std;
  
  class Base  {
      public:
          Base()    { cout << "Constructor: Base" << endl; }
          virtual ~Base()   { cout << "Destructor : Base" << endl; }
  };
  
  class Derived: public Base {
      public:
          Derived()   { cout << "Constructor: Derived" << endl; }
          ~Derived()   { cout << "Destructor : Derived" << endl; }
  };
  
  int main()  {
      Base *Var = new Derived();
      delete Var;
      return 0;
  }
  //Constructor: Base
  //Constructor: Derived
  //Destructor : Derived
  //Destructor : Base
  ```



# 8. vptr 和 vtable

## 8.1 基础理论

为了实现虚函数，C ++使用一种称为虚拟表的特殊形式的后期绑定。该虚拟表是用于解决在动态/后期绑定方式的函数调用函数的查找表。虚拟表有时会使用其他名称，例如“vtable”，“虚函数表”，“虚方法表”或“调度表”。

虚拟表实际上非常简单，虽然用文字描述有点复杂。首先，**每个使用虚函数的类（或者从使用虚函数的类派生）都有自己的虚拟表**。该表只是编译器在编译时设置的静态数组。虚拟表包含可由类的对象调用的每个虚函数的一个条目。此表中的每个条目只是一个函数指针，指向该类可访问的派生函数。

其次，编译器还会添加一个隐藏指向基类的指针，我们称之为vptr。vptr在创建类实例时自动设置，以便指向该类的虚拟表。与this指针不同，this指针实际上是编译器用来解析自引用的函数参数，vptr是一个真正的指针。

因此，它使每个类对象的分配大一个指针的大小。这也意味着vptr由派生类继承，这很重要。

```cpp
//例子没太看懂
#include <iostream>
#include <stdio.h>
using namespace std;

/**
 * @brief 函数指针
 */
typedef void (*Fun)();

/**
 * @brief 基类
 */
class Base
{
    public:
        Base(){};
        virtual void fun1()
        {
            cout << "Base::fun1()" << endl;
        }
        virtual void fun2()
        {
            cout << "Base::fun2()" << endl;
        }
        virtual void fun3(){}
        ~Base(){};
};

/**
 * @brief 派生类
 */
class Derived: public Base
{
    public:
        Derived(){};
        void fun1()
        {
            cout << "Derived::fun1()" << endl;
        }
        void fun2()
        {
            cout << "DerivedClass::fun2()" << endl;
        }
        ~Derived(){};
};
/**
 * @brief 获取vptr地址与func地址,vptr指向的是一块内存，这块内存存放的是虚函数地址，这块内存就是我们所说的虚表
 *
 * @param obj
 * @param offset
 *
 * @return
 */
Fun getAddr(void* obj,unsigned int offset)
{
    cout<<"======================="<<endl;
    void* vptr_addr = (void *)*(unsigned long *)obj;  //64位操作系统，占8字节，通过*(unsigned long *)obj取出前8字节，即vptr指针
    printf("vptr_addr:%p\n",vptr_addr);

    /**
     * @brief 通过vptr指针访问virtual table，因为虚表中每个元素(虚函数指针)在64位编译器下是8个字节，因此通过*(unsigned long *)vptr_addr取出前8字节，
     * 后面加上偏移量就是每个函数的地址！
     */
    void* func_addr = (void *)*((unsigned long *)vptr_addr+offset);
    printf("func_addr:%p\n",func_addr);
    return (Fun)func_addr;
}
int main(void)
{
    Base ptr;
    Derived d;
    Base *pt = new Derived(); // 基类指针指向派生类实例
    Base &pp = ptr; // 基类引用指向基类实例
    Base &p = d; // 基类引用指向派生类实例
    cout<<"基类对象直接调用"<<endl;
    ptr.fun1();
    cout<<"基类对象调用基类实例"<<endl;
    pp.fun1();
    cout<<"基类指针指向基类实例并调用虚函数"<<endl;
    pt->fun1();
    cout<<"基类引用指向基类实例并调用虚函数"<<endl;
    p.fun1();

    // 手动查找vptr 和 vtable
    Fun f1 = getAddr(pt, 0);
    (*f1)();
    Fun f2 = getAddr(pt, 1);
    (*f2)();
    delete pt;
    return 0;
}
```



# 9. virtual

## 9.1.虚函数与运行多态

**虚函数的调用取决于指向或者引用的对象的类型，而不是指针或者引用自身的类型。**

```cpp
#include<iostream>
using namespace std;


class Employee
{
    public:
        virtual void raiseSalary()
        {
            cout<<0<<endl;
        }

        virtual void promote()
        { /* common promote code */ }
};

class Manager: public Employee {
    virtual void raiseSalary()
    {
        cout<<100<<endl;
    }

    virtual void promote()
    { /* Manager specific promote */ }
};
class Engineer: public Employee {
    virtual void raiseSalary()
    {
        cout<<200<<endl;
    }

    virtual void promote()
    { /* Manager specific promote */ }
};

void globalRaiseSalary(Employee *emp[], int n)
{
    for (int i = 0; i < n; i++)
        emp[i]->raiseSalary();
}
int main(){
    Employee *emp[]={new Manager(),new Engineer};
    globalRaiseSalary(emp,2); //100 200
    return 0;
}
```

## 9.2.vptr与vtable

见第 8 个大章节

## 9.3.虚函数中默认参数

**默认参数是静态绑定的，虚函数是动态绑定的。 默认参数的使用需要看指针或者引用本身的类型，而不是对象的类型**。

```cpp
#include <iostream>
using namespace std;

class Base
{
    public:
        virtual void fun ( int x = 10 )
        {
            cout << "Base::fun(), x = " << x << endl;
        }
};

class Derived : public Base
{
    public:
        virtual void fun ( int x=20 )
        {
            cout << "Derived::fun(), x = " << x << endl;
        }
};


int main()
{
    Derived d1;
    Base *bp = &d1;
    bp->fun();  //Derived::fun(), x = 10
    return 0;
}
```

## 9.4.可以不可以

（1） **静态函数可以声明为虚函数吗？**

**静态函数不可以声明为虚函数，同时也不能被const 和 volatile关键字修饰**

static成员函数不属于任何类对象或类实例，所以即使给此函数加上virutal也是没有任何意义

虚函数依靠vptr和vtable来处理。vptr是一个指针，在类的构造函数中创建生成，并且只能用this指针来访问它，静态成员函数没有this指针，所以无法访问vptr。

```cpp
//这两个都是错的
virtual static void fun()  { }
static void fun() const { }
```

（2）**构造函数可以为虚函数吗？**

构造函数不可以声明为虚函数。同时除了inline|explicit之外，构造函数不允许使用其它任何关键字。

尽管虚函数表vtable是在编译阶段就已经建立的，但指向虚函数表的指针vptr是在运行阶段实例化对象时才产生的。 如果类含有虚函数，编译器会在构造函数中添加代码来创建vptr。 问题来了，如果构造函数是虚的，那么它需要vptr来访问vtable，可这个时候vptr还没产生。 因此，构造函数不可以为虚函数。

我们之所以使用虚函数，是因为需要在信息不全的情况下进行多态运行。而构造函数是用来初始化实例的，实例的类型必须是明确的。

```cpp
#include <iostream>
using namespace std;

class Base
{
    public:

};

class Derived : public Base
{
    public:
        Derived()
        {
            cout << "Derived created" << endl;
        }

        Derived(const Derived &rhs)
        {
            cout << "Derived created by deep copy" << endl;
        }

        ~Derived()
        {
            cout << "Derived destroyed" << endl;
        }
};

int main()
{
    Derived s1;
    Derived s2 = s1;
    return 0;
}
//Derived created
//Derived created by deep copy
//Derived destroyed
//Derived destroyed
```

```cpp
/**
 * @file vir_con.cpp
 * @brief 构造函数不可以声明为虚函数。同时除了inline之外，构造函数不允许使用其它任何关键字。
 *
 * 为什么构造函数不可以为虚函数？
 *
 * 尽管虚函数表vtable是在编译阶段就已经建立的，但指向虚函数表的指针vptr是在运行阶段实例化对象时才产生的。 如果类含有虚函数，编译器会在构造函数中添加代码来创建vptr。 问题来了，如果构造函数是虚的，那么它需要vptr来访问vtable，可这个时候vptr还没产生。 因此，构造函数不可以为虚函数。
 * 我们之所以使用虚函数，是因为需要在信息不全的情况下进行多态运行。而构造函数是用来初始化实例的，实例的类型必须是明确的。
 * 因此，构造函数没有必要被声明为虚函数。
 * 尽管构造函数不可以为虚函数，但是有些场景下我们确实需要 “Virtual Copy Constructor”。 “虚复制构造函数”的说法并不严谨，其只是一个实现了对象复制的功能的类内函数。 举一个应用场景，比如剪切板功能。 复制内容作为基类，但派生类可能包含文字、图片、视频等等。 我们只有在程序运行的时候才知道我们需要复制的具体是什么类型的数据。
 *
 * @author 光城
 * @version v1
 * @date 2019-07-24
 */

#include <iostream>
using namespace std;

//// LIBRARY SRART
class Base
{
    public:
        Base() { }

        virtual // Ensures to invoke actual object destructor
            ~Base() { }

        virtual void ChangeAttributes() = 0;

        // The "Virtual Constructor"
        static Base *Create(int id);

        // The "Virtual Copy Constructor"
        virtual Base *Clone() = 0;
};

class Derived1 : public Base
{
    public:
        Derived1()
        {
            cout << "Derived1 created" << endl;
        }

        Derived1(const Derived1& rhs)
        {
            cout << "Derived1 created by deep copy" << endl;
        }

        ~Derived1()
        {
            cout << "~Derived1 destroyed" << endl;
        }

        void ChangeAttributes()
        {
            cout << "Derived1 Attributes Changed" << endl;
        }

        Base *Clone()
        {
            return new Derived1(*this);
        }
};

class Derived2 : public Base
{
    public:
        Derived2()
        {
            cout << "Derived2 created" << endl;
        }

        Derived2(const Derived2& rhs)
        {
            cout << "Derived2 created by deep copy" << endl;
        }

        ~Derived2()
        {
            cout << "~Derived2 destroyed" << endl;
        }

        void ChangeAttributes()
        {
            cout << "Derived2 Attributes Changed" << endl;
        }

        Base *Clone()
        {
            return new Derived2(*this);
        }
};

class Derived3 : public Base
{
    public:
        Derived3()
        {
            cout << "Derived3 created" << endl;
        }

        Derived3(const Derived3& rhs)
        {
            cout << "Derived3 created by deep copy" << endl;
        }

        ~Derived3()
        {
            cout << "~Derived3 destroyed" << endl;
        }

        void ChangeAttributes()
        {
            cout << "Derived3 Attributes Changed" << endl;
        }

        Base *Clone()
        {
            return new Derived3(*this);
        }
};

// We can also declare "Create" outside Base.
// But is more relevant to limit it's scope to Base
Base *Base::Create(int id)
{
    // Just expand the if-else ladder, if new Derived class is created
    // User need not be recompiled to create newly added class objects

    if( id == 1 )
    {
        return new Derived1;
    }
    else if( id == 2 )
    {
        return new Derived2;
    }
    else
    {
        return new Derived3;
    }
}
//// LIBRARY END

//// UTILITY SRART
class User
{
    public:
        User() : pBase(0)
    {
        // Creates any object of Base heirarchey at runtime

        int input = 1;

//        cout << "Enter ID (1, 2 or 3): ";
//        cin >> input;

        while( (input != 1) && (input != 2) && (input != 3) )
        {
            cout << "Enter ID (1, 2 or 3 only): ";
            cin >> input;
        }

        // Create objects via the "Virtual Constructor"
        pBase = Base::Create(input);
    }

        ~User()
        {
            if( pBase )
            {
                delete pBase;
                pBase = 0;
            }
        }

        void Action()
        {
            // Duplicate current object
            Base *pNewBase = pBase->Clone();

            // Change its attributes
            pNewBase->ChangeAttributes();

            // Dispose the created object
            delete pNewBase;
        }

    private:
        Base *pBase;
};

//// UTILITY END

//// Consumer of User (UTILITY) class
int main()
{
    User *user = new User();

    user->Action();

    delete user;
}
//Derived1 created
//Derived1 created by deep copy
//Derived1 Attributes Changed
//~Derived1 destroyed
//~Derived1 destroyed
```

（3）**析构函数可以为虚函数吗？**

**析构函数可以声明为虚函数。如果我们需要删除一个指向派生类的基类指针时，应该把析构函数声明为虚函数。 事实上，只要一个类有可能会被其它类所继承， 就应该声明虚析构函数(哪怕该析构函数不执行任何操作)。**

```cpp
/**
 * @file full_virde.cpp
 * @brief 将基类的析构函数声明为虚函数
 * 输出结果：
 *      Constructing base
 *      Constructing derived
 *      Destructing derived
 *      Destructing base
 * @author 光城
 * @version v1
 * @date 2019-07-24
 */
#include<iostream> 

using namespace std; 

class base { 
    public: 
        base()      
        { cout<<"Constructing base \n"; } 
        virtual ~base() 
        { cout<<"Destructing base \n"; }      
}; 

class derived: public base { 
    public: 
        derived()      
        { cout<<"Constructing derived \n"; } 
        ~derived() 
        { cout<<"Destructing derived \n"; } 
}; 

int main(void) 
{ 
    derived *d = new derived();   
    base *b = d; 
    delete b; 
    return 0; 
} 
// Constructing base 
// Constructing derived 
// Destructing derived 
// Destructing base
```

```cpp
/**
 * @file vir_de.cpp
 * @brief 派生类的析构函数没有被调用!
 * 输出结果：
 *      Constructing base
 *      Constructing derived
 *      Destructing base
 * @author 光城
 * @version v1
 * @date 2019-07-24
 */

// CPP program without virtual destructor  
// causing undefined behavior 
#include<iostream> 

using namespace std; 

class base { 
    public: 
        base()      
        { cout<<"Constructing base \n"; } 
        ~base() 
        { cout<<"Destructing base \n"; }      
}; 

class derived: public base { 
    public: 
        derived()      
        { cout<<"Constructing derived \n"; } 
        ~derived() 
        { cout<<"Destructing derived \n"; } 
}; 

int main(void) 
{ 
    derived *d = new derived();   
    base *b = d; 
    delete b; 
    return 0; 
} 
// Constructing base 
// Constructing derived 
// Destructing base
```

（4）**虚函数可以为私有函数吗？**

他说的和我实际做的不一样。不加friend且public也可以跑通。

```cpp
/**
 * @file virtual_function.cpp
 * @brief 虚函数可以被私有化，但有一些细节需要注意。
 * 基类指针指向继承类对象，则调用继承类对象的函数；
 * int main()必须声明为Base类的友元，否则编译失败。 编译器报错： ptr无法访问私有函数。 
 * 当然，把基类声明为public， 继承类为private，该问题就不存在了。----> 见另外一个例子！
 * @author 光城
 * @version v1
 * @date 2019-07-24
 */

#include<iostream> 
using namespace std; 

class Derived; 

class Base { 
    private: 
        virtual void fun() { cout << "Base Fun"; } 
        friend int main(); 
}; 

class Derived: public Base { 
    public: 
        void fun() { cout << "Derived Fun"; } 
}; 

int main() 
{ 
    Base *ptr = new Derived; 
    ptr->fun(); 
    return 0; 
}
//Derived Fun
```

```cpp
#include<iostream> 
using namespace std; 

class Derived; 

class Base { 
    public: 
        virtual void fun() { cout << "Base Fun"; } 
     //   friend int main(); 
}; 

class Derived: public Base { 
    private: 
        void fun() { cout << "Derived Fun"; } 
}; 

int main() 
{ 
    Base *ptr = new Derived; 
    ptr->fun(); 
    return 0; 
}
//Derived Fun
```

（5）**虚函数可以被内联吗？**

**通常类成员函数都会被编译器考虑是否进行内联。 但通过基类指针或者引用调用的虚函数必定不能被内联。 当然，实体对象调用虚函数或者静态调用时可以被内联，虚析构函数的静态调用也一定会被内联展开。**

* 虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。
* 内联是在编译器建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。
* `inline virtual` 唯一可以内联的时候是：编译器知道所调用的对象是哪个类（如 `Base::who()`），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。

```cpp
/**
 * @file virtual_inline.cpp
 * @brief 通常类成员函数都会被编译器考虑是否进行内联。 
 * 但通过基类指针或者引用调用的虚函数必定不能被内联。
 * 当然，实体对象调用虚函数或者静态调用时可以被内联，虚析构函数的静态调用也一定会被内联展开。
 * @author 光城
 * @version v1
 * @date 2019-07-24
 */

#include <iostream> 
using namespace std; 
class Base 
{ 
    public: 
        virtual void who() 
        { 
            cout << "I am Base\n"; 
        } 
}; 
class Derived: public Base 
{ 
    public: 
        void who() 
        {  
            cout << "I am Derived\n"; 
        } 
}; 

int main() 
{ 
    // note here virtual function who() is called through 
    // object of the class (it will be resolved at compile 
    // time) so it can be inlined. 
    Base b; 
    b.who(); 

    // Here virtual function is called through pointer, 
    // so it cannot be inlined 
    Base *ptr = new Derived(); 
    ptr->who(); 

    return 0; 
} 
```

```cpp
#include <iostream>  
using namespace std;
class Base
{
    public:
        inline virtual void who()
        {
            cout << "I am Base\n";
        }
        virtual ~Base() {}
};
class Derived : public Base
{
    public:
        inline void who()  // 不写inline时隐式内联
        {
            cout << "I am Derived\n";
        }
};

int main()
{
    // 此处的虚函数 who()，是通过类（Base）的具体对象（b）来调用的，编译期间就能确定了，所以它可以是内联的，但最终是否内联取决于编译器。 
    Base b;
    b.who();

    // 此处的虚函数是通过指针调用的，呈现多态性，需要在运行时期间才能确定，所以不能为内联。  
    Base *ptr = new Derived();
    ptr->who();

    // 因为Base有虚析构函数（virtual ~Base() {}），所以 delete 时，会先调用派生类（Derived）析构函数，再调用基类（Base）析构函数，防止内存泄漏。
    delete ptr;

    return 0;
} 
```

## 9.5.RTTI与dynamic_cast

RTTI（Run-Time Type Identification)，通过运行时类型信息程序能够使用[基类](https://baike.baidu.com/item/基类/9589663)的[指针](https://baike.baidu.com/item/指针/2878304)或引用来检查这些指针或引用所指的对象的实际[派生类](https://baike.baidu.com/item/派生类)型。

```cpp
/**
 * @file rtti.cpp
 * @brief 在面向对象程序设计中，有时我们需要在运行时查询一个对象是否能作为某种多态类型使用。与Java的instanceof，以及C#的as、is运算符类似，C++提供了dynamic_cast函数用于动态转型。相比C风格的强制类型转换和C++ reinterpret_cast，dynamic_cast提供了类型安全检查，是一种基于能力查询(Capability Query)的转换，所以在多态类型间进行转换更提倡采用dynamic_cast
 * @author 光城
 * @version v1
 * @date 2019-07-24
 */

// CPP program to illustrate  
// // Run Time Type Identification  
#include<iostream>
#include<typeinfo>
using namespace std; 
class B { virtual void fun() {} }; 
class D: public B { }; 

int main() 
{ 
    B *b = new D;  // 向上转型
    B &obj = *b;
    D *d = dynamic_cast<D*>(b);   // 向下转型
    if(d != NULL) 
        cout << "works"<<endl; 
    else
        cout << "cannot cast B* to D*"; 
 
    try {
        D& dobj = dynamic_cast<D&>(obj);  
        cout << "works"<<endl; 
    } catch (bad_cast bc) { // ERROR
        cout<<bc.what()<<endl;
    }
    return 0;
}
```

```cpp
// 在使用时需要注意：被转换对象obj的类型T1必须是多态类型，即T1必须公有继承自其它类，或者T1拥有虚函数（继承或自定义）。若T1为非多态类型，使用dynamic_cast会报编译错误。

// A为非多态类型 

class A{

};

//B为多态类型

class B{ 

    public: virtual ~B(){}

};

//D为非多态类型

class D: public A{

};

//E为非多态类型

class E : private A{

};

//F为多态类型

class F : private B{

}
```

## 9.6.纯虚函数和抽象类

见第7章

# 10. volatile

多线程。每次都要去内存取数据，禁止编译器优化。

# 11. assert

断言。

```cpp
#include <stdio.h> 
#include <assert.h> 

int main() 
{ 
    int x = 7; 

    /*  Some big code in between and let's say x  
    is accidentally changed to 9  */
    x = 9; 

    // Programmer assumes x to be 7 in rest of the code 
    assert(x==7); 

    /* Rest of the code */

    return 0; 
} 
/*
t2: t2.cpp:13: int main(): Assertion `x==7' failed.
已放弃 (核心已转储)
*/
```

在最上面加上一句就行了

```cpp
# define NDEBUG // 忽略断言

#include<assert.h>

int main(){
    int x=7;
    assert(x==5);
    return 0;
}
```

# 12. 位域

位段在本质上是不可移植的

```
struct bit_field_name
{
	type member_name : width;
};
```

| Elements       | Description                                                  |
| -------------- | ------------------------------------------------------------ |
| bit_field_name | 位域结构名                                                   |
| type           | 位域成员的类型，必须为 int、signed int 或者 unsigned int 类型 |
| member_name    | 位域成员名                                                   |
| width          | 规定成员所占的位数                                           |

例如声明如下一个位域:

```
struct _PRCODE
{
	unsigned int code1: 2;
	unsigned int cdde2: 2;
	unsigned int code3: 8;
};
struct _PRCODE prcode;
```

该定义使 `prcode`包含 2 个 2 Bits 位域和 1 个 8 Bits 位域，我们可以使用结构体的成员运算符对其进行赋值

```
prcode.code1 = 0;
prcode.code2 = 3;
procde.code3 = 102;
```

赋值时要注意值的大小不能超过位域成员的容量，例如 prcode.code3 为 8 Bits 的位域成员，其容量为 2^8 = 256，即赋值范围应为 [0,255]。

# 13. extern

C++虽然兼容C，但C++文件中函数编译后生成的符号与C语言生成的不同。因为C++支持函数重载，C++函数编译后生成的符号带有函数参数类型的信息，而C则没有。

**C++调用C**

```cpp
//add.h
#ifndef ADD_H
#define ADD_H
extern int add(int x,int y);
#endif

//add.c
#include "add.h"

int add(int x,int y) {
    return x+y;
}

//add.cpp
#include <iostream>
using namespace std;
#ifdef __cplusplus
extern "C"{
#endif
int add(int x,int y);
#ifdef __cplusplus
}
#endif
int main() {
    add(2,3);
    return 0;
}
```

编译步骤

```
gcc -c add.c 
g++ add.cpp add.o -o main
```



**C中调用C++**

`extern "C"`在C中是语法错误，需要放在C++头文件中。

```cpp
//add.h
#ifndef ADD_H
#define ADD_H
extern "C" {
    int add(int x,int y);
}
#endif

//add.cpp
#include "add.h"

int add(int x,int y) {
    return x+y;
}

//add.c
extern int add(int x,int y);
int main() {
    add(2,3);
    return 0;
}
```

编译方式

```
g++ -c add.cpp
gcc add.c add.o -o main
```

# 14. struct

## 1. C中struct

- 在C中struct只单纯的用作数据的复合类型，也就是说，在结构体声明中只能将数据成员放在里面，而不能将函数放在里面。
- 在C结构体声明中不能使用C++访问修饰符，如：public、protected、private 而在C++中可以使用。
- 在C中定义结构体变量，如果使用了下面定义必须加struct。
- C的结构体不能继承（没有这一概念）。
- 若结构体的名字与函数名相同，可以正常运行且正常的调用！例如：可以定义与 struct Base 不冲突的 void Base() {}。

## 2.C++中struct

与C对比如下：

- C++结构体中不仅可以定义数据，还可以定义函数。
- C++结构体中可以使用访问修饰符，如：public、protected、private 。
- C++结构体使用可以直接使用不带struct。
- C++继承
- 若结构体的名字与函数名相同，可以正常运行且正常的调用！但是定义结构体变量时候只能用带struct的！



# 15. union

联合（union）是一种节省空间的特殊的类，一个 union 可以有多个数据成员，但是在任意时刻只有一个数据成员可以有值。当某个成员被赋值后其他成员变为未定义状态。联合有如下特点：

- 默认访问控制符为 public
- 可以含有构造函数、析构函数
- 不能含有引用类型的成员
- 不能继承自其他类，不能作为基类
- 不能含有虚函数
- 匿名 union 在定义所在作用域可直接访问 union 成员
- 匿名 union 不能包含 protected 成员或 private 成员
- 全局匿名联合必须是静态（static）的



# 16. explicit

- explicit 修饰构造函数时，可以防止隐式转换和复制初始化
- explicit 修饰转换函数时，可以防止隐式转换，但按语境转换除外

```cpp
#include <iostream>

using namespace std;

struct A
{
    A(int) { }
    operator bool() const { return true; }
};

struct B
{
    explicit B(int) {}
    explicit operator bool() const { return true; }
};

void doA(A a) {}

void doB(B b) {}

int main()
{
    A a1(1);        // OK：直接初始化
    A a2 = 1;        // OK：复制初始化
    A a3{ 1 };        // OK：直接列表初始化
    A a4 = { 1 };        // OK：复制列表初始化
    A a5 = (A)1;        // OK：允许 static_cast 的显式转换 
    doA(1);            // OK：允许从 int 到 A 的隐式转换
    if (a1);        // OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换
    bool a6(a1);        // OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换
    bool a7 = a1;        // OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换
    bool a8 = static_cast<bool>(a1);  // OK ：static_cast 进行直接初始化

    B b1(1);        // OK：直接初始化
//    B b2 = 1;        // 错误：被 explicit 修饰构造函数的对象不可以复制初始化
    B b3{ 1 };        // OK：直接列表初始化
//    B b4 = { 1 };        // 错误：被 explicit 修饰构造函数的对象不可以复制列表初始化
    B b5 = (B)1;        // OK：允许 static_cast 的显式转换
//    doB(1);            // 错误：被 explicit 修饰构造函数的对象不可以从 int 到 B 的隐式转换
    if (b1);        // OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换
    bool b6(b1);        // OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换
//    bool b7 = b1;        // 错误：被 explicit 修饰转换函数 B::operator bool() 的对象不可以隐式转换
    bool b8 = static_cast<bool>(b1);  // OK：static_cast 进行直接初始化

    return 0;
}
```



# 17. friend

友元提供了一种 普通函数或者类成员函数 访问另一个类中的私有或保护成员 的机制。也就是说有两种形式的友元：

（1）友元函数：普通函数对一个访问某个类中的私有或保护成员。

（2）友元类：类A中的成员函数访问类B中的私有或保护成员

优点：提高了程序的运行效率。

缺点：破坏了类的封装性和数据的透明性。

总结：

- 能访问私有成员
- 破坏封装性
- 友元关系不可传递
- 友元关系的单向性
- 友元声明的形式及数量不受限制

**友元函数**

```cpp
#include <iostream>

using namespace std;

class A
{
public:
    A(int _a):a(_a){};
    friend int geta(A &ca);  ///< 友元函数
private:
    int a;
};

int geta(A &ca) 
{
    return ca.a;
}

int main()
{
    A a(3);    
    cout<<geta(a)<<endl;

    return 0;
}
```

**友元类**

```cpp
#include <iostream>

using namespace std;

class A
{
public:
    A(int _a):a(_a){};
    friend class B;
private:
    int a;
};

class B
{
public:
    int getb(A ca) {
        return  ca.a; 
    };
};

int main() 
{
    A a(3);
    B b;
    cout<<b.getb(a)<<endl;
    return 0;
}
```

注意

- 友元关系没有继承性 假如类B是类A的友元，类C继承于类A，那么友元类B是没办法直接访问类C的私有或保护成员。
- 友元关系没有传递性 假如类B是类A的友元，类C是类B的友元，那么友元类C是没办法直接访问类A的私有或保护成员，也就是不存在“友元的友元”这种关系。



# 18 using

**局部和全局的 using**

```cpp
#include <iostream>
// #define isNs1 1
// #define isGlobal 2
using namespace std;
void func() 
{
    cout<<"::func"<<endl;
}

namespace ns1 {
    void func()
    {
        cout<<"ns1::func"<<endl; 
    }
}

namespace ns2 {
#ifdef isNs1 
    using ns1::func;    /// ns1中的函数
#elif isGlobal
    using ::func; /// 全局中的函数
#else
    void func() 
    {
        cout<<"other::func"<<endl; 
    }
#endif
}

int main() 
{
    /**
     * 这就是为什么在c++中使用了cmath而不是math.h头文件
     */
    ns2::func(); // 会根据当前环境定义宏的不同来调用不同命名空间下的func()函数
    return 0;
}
```

**改变访问性**

```cpp
class Base {
public:
	std::size_t size() const { return n; }
protected:
	std::size_t n;
};
class Derived : private Base {
public:
	using Base::size;
protected:
	using Base::n;
};
```

类Derived私有继承了Base，对于它来说成员变量n和成员函数size都是私有的，如果使用了using语句，可以改变他们的可访问性，如上述例子中，size可以按public的权限访问，n可以按protected的权限访问。 

**函数重载**

在继承过程中，派生类可以覆盖重载函数的0个或多个实例，一旦定义了一个重载版本，那么其他的重载版本都会变为不可见。

如果对于基类的重载函数，我们需要在派生类中修改一个，又要让其他的保持可见，必须要重载所有版本，这样十分的繁琐。

```cpp
#include <iostream>
using namespace std;

class Base{
    public:
        void f(){ cout<<"f()"<<endl;
        }
        void f(int n){
            cout<<"Base::f(int)"<<endl;
        }
};

class Derived : private Base {
    public:
        using Base::f;
        void f(int n){
            cout<<"Derived::f(int)"<<endl;
        }
};

int main()
{
    Base b;
    Derived d;
    d.f();
    d.f(1);
    return 0;
}
```

如上代码中，在派生类中使用using声明语句指定一个名字而不指定形参列表，所以一条基类成员函数的using声明语句就可以把该函数的所有重载实例添加到派生类的作用域中。此时，派生类只需要定义其特有的函数就行了，而无需为继承而来的其他函数重新定义。

**取代typedef**

```cpp
typedef vector<int> V1;
using V2 = vector<int>;
```

